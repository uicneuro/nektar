//! @file
//! 
//! This source file was generated from NeuronML.
//! 
//! Model: Hodgkin and Huxley model
//! 
//! <autogenerated>

#include <iostream>
#include <string>
//#inc lude <LibUtilities/BasicUtils/Vmath.hpp>
#include <DiffusionSolver/NeuronModels/HodgkinHuxley.h>

namespace Nektar
{
    std::string HodgkinHuxley::className
              = GetNeuronModelFactory().RegisterCreatorFunction("HodgkinHuxley",
                        HodgkinHuxley::create, "Hodgkin Huxley model.");
    
    // gate variable 1: m 
    // gate variable 2: h
    // gate variable 3: n
    HodgkinHuxley::HodgkinHuxley(
                const LibUtilities::SessionReaderSharedPtr& pSession,
                const MultiRegions::ExpListSharedPtr& pField):
            NeuronModel(pSession, pField)
    {
        m_nq   = pField->GetNpoints();

        const NekDouble var_membrane__Cm = 1.0e-10; //Leakage potential (MV)

        m_nvar = 4;
        m_gates.push_back(1);
        m_gates.push_back(2);
        m_gates.push_back(3);

        m_Cm = var_membrane__Cm;
    }
    
    void HodgkinHuxley::v_Update(
                        const Array<OneD, const int> &RvNodeZone,
                     const Array<OneD, const  Array<OneD, NekDouble> >&inarray,
                           Array<OneD,        Array<OneD, NekDouble> >&outarray,
                                                           const NekDouble time, 
                                                           const NekDouble diameter,
                                                           const NekDouble Tc)
    {
        boost::ignore_unused(RvNodeZone,Tc);
        boost::ignore_unused(time);
        boost::ignore_unused(diameter);

        const NekDouble Tol = 1.0e-10;

        const NekDouble var_membrane__VL = -0.060; //Leakage potential (MV)
        const NekDouble var_membrane__ENa = 0.045; //Leakage potential (MV)
        const NekDouble var_membrane__EK = -0.082; //Leakage potential (MV)

        const NekDouble var_membrane__GL = 3.0e-8; //Leakage potential (MV)
        const NekDouble var_membrane__GNa =1.2e-5; //Leakage potential (MV)
        const NekDouble var_membrane__GK = 3.6e-6; //Leakage potential (MV)

        for (unsigned int i = 0; i < m_nq; ++i)
        {
            // Inputs:
            // Time units: millisecond
            NekDouble var_membrane_V = inarray[0][i];
            NekDouble var_m_gate = inarray[1][i];
            NekDouble var_h_gate = inarray[2][i];
            NekDouble var_n_gate = inarray[3][i];

            NekDouble d_dt_membrane__V;

            // m gate: m_inf = (alpha_m / (alpha_m+beta_m) ),   m_tau = (1.0 / (alpha_m+beta_m) )/ Q10(T)
            const NekDouble var_current_m = var_m_gate; // dimensionless
            NekDouble alpha_m;
            if(fabs(var_membrane_V+0.045)<Tol)
            {
                alpha_m = 1.0e3;
            }

            else
            {
                alpha_m = 1.0e5*(-var_membrane_V - 0.045)/(exp(100*(-var_membrane_V-0.045))-1.0); 
            }
            const NekDouble beta_m = 4.0e3*exp( (-var_membrane_V-0.070)/0.018 );  // dimensionless
            const NekDouble m_inf = alpha_m/(alpha_m + beta_m);
            const NekDouble m_tau = 1.0/(alpha_m + beta_m);

            // h gate: h_inf = (alpha_h / (alpha_h + beta_h) ),   h_tau = (1.0 / (alpha_h + beta_h) )
            const NekDouble var_current_h = var_h_gate; // dimensionless
            const NekDouble alpha_h = 70.0 * exp(50.0*(-var_membrane_V-0.070)) ; // dimensionless
            const NekDouble beta_h = 1.0e3/(1.0 + exp(100.0*(-var_membrane_V-0.040)) ) ; // dimensionless
            const NekDouble h_inf = alpha_h/(alpha_h + beta_h);
            const NekDouble h_tau = 1.0/(alpha_h + beta_h);

            // n gate: n_inf = (alpha_n / (alpha_n + beta_n) ),   n_tau = (1.0 / (alpha_h + beta_h) )
            const NekDouble var_current_n = var_n_gate; // dimensionless
            NekDouble alpha_n;
            if(fabs(var_membrane_V+0.060)<Tol)
            {
               alpha_n = 100.0;
            }

            else
            {
               alpha_n = 1.0e4 * (-var_membrane_V - 0.060)/(exp(100*(-var_membrane_V-0.060))-1.0); 
            }

            const NekDouble beta_n = 125.0*exp( (-var_membrane_V-0.070)/0.08 );  // dimensionless
            const NekDouble n_inf = alpha_n/(alpha_n + beta_n);
            const NekDouble n_tau = 1.0/(alpha_n + beta_n);

            // Compute current_K
            NekDouble var_J_Na = var_membrane__GNa * var_current_m * var_current_m * var_current_m * var_current_h * (var_membrane__ENa - var_membrane_V);
            NekDouble var_J_K = var_membrane__GK * var_current_n * var_current_n * var_current_n * var_current_n * (var_membrane__EK - var_membrane_V);
            NekDouble var_J_l = var_membrane__GL * ( var_membrane__VL - var_membrane_V );
            d_dt_membrane__V = var_J_l + var_J_K + var_J_Na;

            outarray[0][i] = d_dt_membrane__V ;

            outarray[1][i] = m_inf;
            m_gates_tau[0][i] = m_tau;

            outarray[2][i] = h_inf;
            m_gates_tau[2][i] = h_tau;

            outarray[3][i] = n_inf;
            m_gates_tau[1][i] = n_tau; 
        }
    }


    /**
    *
    */
    void HodgkinHuxley::v_GenerateSummary(SummaryList& s)
    {
        SolverUtils::AddSummaryItem(s, "Neuron model", "Hodgekin Huxley 64");
    }


NekDouble HodgkinHuxley::RootMeanSquare(const Array<OneD, const NekDouble> &inarray,
                                    const int Ntot)
{
    int nq = inarray.size();

    NekDouble reval = 0.0;
    for (int i = 0; i < nq; ++i)
    {
        reval += inarray[i] * inarray[i];
    }

    if (Ntot)
    {
        reval = sqrt(reval / Ntot);
    }

    else
    {
        reval = sqrt(reval / nq);
    }

    return reval;
}

    /**
     *
     */
    void HodgkinHuxley::v_SetInitialConditions()
    {
        Vmath::Fill(m_nq, -0.065,  m_NeuronSol[0],  1);
        Vmath::Fill(m_nq, 0.05,    m_NeuronSol[1],  1);
        Vmath::Fill(m_nq, 0.5,     m_NeuronSol[2],  1);
        Vmath::Fill(m_nq, 0.35,    m_NeuronSol[3],  1);
    }

}
        
