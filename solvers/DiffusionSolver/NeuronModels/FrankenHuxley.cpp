//! @file
//! 
//! This source file was generated from NeuronML.
//! 
//! Model: Frankenhaeuser and Huxley model 1964, reparametrized by Reutskiy-Rossoni-Tirozzi 2003
//! 
//! Processed by pycml - NeuronML Tools in Python
//!     (translators: 12434, pycml: 12383, optimize: 12408)
//! on Thu Oct 20 12:52:22 2011
//! 
//! <autogenerated>

#include <iostream>
#include <string>
//#inc lude <LibUtilities/BasicUtils/Vmath.hpp>
#include <DiffusionSolver/NeuronModels/FrankenHuxley.h>

namespace Nektar
{
    std::string FrankenHuxley::className
              = GetNeuronModelFactory().RegisterCreatorFunction("FrankenHuxley", FrankenHuxley::create,
                         "Frankenhaeuser and Huxley model 1964.");
    
    // gate variable 1: m 
    // gate variable 2: n
    // gate variable 3: h
    // gate variable 4: p

    FrankenHuxley::FrankenHuxley(
                const LibUtilities::SessionReaderSharedPtr& pSession,
                const MultiRegions::ExpListSharedPtr& pField):
            NeuronModel(pSession, pField)
    {
        m_nq   = pField->GetNpoints();

        //  Nodal and demyelinated axolemma capacitance per unit axon length (F/cm)
        // const NekDouble var_membrane__cnd = 1.0e-6;  //  Waxman
        const NekDouble var_membrane__cnd = 3.14e-9; 

        //  Myelinated capacitance per unit axon length (F/cm)
        const NekDouble var_membrane__cml = 1.87e-11; 

        // axoplasmic resistance per unit axon length  (ohm/cm)
        const NekDouble var_membrane__ra = 1.26e8; 

        m_nvar = 5;
        m_gates.push_back(1);
        m_gates.push_back(2);
        m_gates.push_back(3);
        m_gates.push_back(4);

        // Myelin capacitance
        m_Cm = var_membrane__cml;

        // Nodal and demyelinated capacitance
        m_Cn = var_membrane__cnd;

        // Diffusion Coefficient 
        m_ra = var_membrane__ra;
    }

    void FrankenHuxley::v_Update(
                     const Array<OneD, const int> &zoneindex,
                     const Array<OneD, const  Array<OneD, NekDouble> >&inarray,
                           Array<OneD,        Array<OneD, NekDouble> >&outarray,
                                                           const NekDouble time,
                                                           const NekDouble var_membrane__d,
                                                           const NekDouble var_membrane__Tc)
    {
        boost::ignore_unused(time);

        // nodal capacitance
        const NekDouble var_membrane__cnd = 3.14e-9;  // (F/cm) Waxman 1978, Same

        // myelin capacitance
        const NekDouble var_membrane__cml = 1.87e-11;  // (F/cm) Waxman 1978, Same

        const NekDouble var_membrane__PNa = 0.008; //Max. Na, f channel permeability (cm/s)
        const NekDouble var_membrane__Pp = 0.00054; //Max. Na, p channel permeability (cm/s)
        const NekDouble var_membrane__PK = 0.0012; //Max. K channel permeability (cm/s)

        const NekDouble var_membrane__Na_o = 114.5; // External Na^{+} concentration (mol)
        const NekDouble var_membrane__Na_i = 13.74; // internal Na^{+} concentration (mol)
        const NekDouble var_membrane__K_o = 2.5; // External K^{+} concentration (mol)
        const NekDouble var_membrane__K_i = 120.0; // internal K^{+} concentration (mol)

        const NekDouble var_membrane__gL = 0.0303; // Leakage-specific conductance (mho/cm2)
        const NekDouble var_membrane__gm = 5.60e-9; // Myelin conductance (F/cm)

        // const NekDouble var_membrane__d = 1.0e-3; // bare Axon diameter(cm)
        // const NekDouble var_membrane__D = 1.5e-3; // myelinated Axon diameter(cm)
        // const NekDouble var_membrane__l = 2.5e-4; // Nodal length (cm)
        // const NekDouble var_membrane__L = 2.0e-1; // Internoal length (cm)

        const NekDouble var_membrane__VL = 0.026; //Leakage potential (mV)
        const NekDouble var_membrane__Vrest = -70.0; // Resting potential (mV)

        // m-gate constant 
        const NekDouble gate_m_alphaA = 0.36 ; // ms^{-1}
        const NekDouble gate_m_alphaB = 22.0 ; // mV
        const NekDouble gate_m_alphaC = 3.0 ; // mV
        const NekDouble gate_m_betaA = 0.4; // ms^{-1}
        const NekDouble gate_m_betaB = 13.0 ; // mV
        const NekDouble gate_m_betaC = 20.0 ; // mV

        // n-gate constant 
        const NekDouble gate_n_alphaA = 0.02 ; // ms^{-1}
        const NekDouble gate_n_alphaB = 35.0 ; // mV
        const NekDouble gate_n_alphaC = 10.0 ; // mV
        const NekDouble gate_n_betaA = 0.05 ; // ms^{-1}
        const NekDouble gate_n_betaB = 10.0 ; // mV
        const NekDouble gate_n_betaC = 10.0 ; // mV

        // h-gate constant 
        const NekDouble gate_h_alphaA = 0.1 ; // ms^{-1}
        const NekDouble gate_h_alphaB = -10.0 ; // mV
        const NekDouble gate_h_alphaC = 6.0 ; // mV
        const NekDouble gate_h_betaA = 4.5  ; // s^{-1}
        const NekDouble gate_h_betaB = 45.0 ; // mV
        const NekDouble gate_h_betaC = 10.0 ; // mV

        // p-gate constant 
        const NekDouble gate_p_alphaA = 0.006 ; // ms^{-1}
        const NekDouble gate_p_alphaB = 40.0 ; // mV
        const NekDouble gate_p_alphaC = 10.0 ; // mV
        const NekDouble gate_p_betaA = 0.09 ; // ms^{-1}
        const NekDouble gate_p_betaB = -25.0 ; // mV
        const NekDouble gate_p_betaC = 20.0 ; // mV

        NekDouble var_membrane_V, var_current_m, var_current_n, var_current_h, var_current_p;

        NekDouble E, d_dt_membrane__V = 0.0;

        NekDouble Q10Tpow = 0.1*(var_membrane__Tc-20.0);
        NekDouble Q10T = pow(3.0, Q10Tpow);
        for (unsigned int i = 0; i < m_nq; ++i)
        {
            // Time units: millisecond
             var_membrane_V = inarray[0][i];
            // Units: millivolt; Initial value: -84.3801107371
             var_current_m = inarray[1][i];
            // Units: dimensionless; Initial value: 0.00171338077730188
             var_current_n = inarray[2][i];
            // Units: dimensionless; Initial value: 0.982660523699656
             var_current_h = inarray[3][i];
            // Units: dimensionless; Initial value: 0.989108212766685
             var_current_p = inarray[4][i];
            // Units: millimolar; Initial value: 0.00017948816388306

            // m gate: m_inf = (alpha_m / (alpha_m+beta_m) ),   m_tau = (1.0 / (alpha_m+beta_m) )/ Q10(T)
            // const NekDouble var_current_m = var_m_gate; // dimensionless
            NekDouble alpha_m = Q10T * gate_m_alphaA * ComputeexpM1( gate_m_alphaB - var_membrane_V, gate_m_alphaC);
            NekDouble beta_m = Q10T * gate_m_betaA * ComputeexpM1( var_membrane_V - gate_m_betaB, gate_m_betaC);
            NekDouble m_inf = alpha_m/(alpha_m + beta_m);
            NekDouble m_tau = 1.0/(alpha_m + beta_m);

            // n gate: n_inf = (alpha_n / (alpha_n + beta_n) ),   n_tau = (1.0 / (alpha_n + beta_n) )
            // const NekDouble var_current_n = var_n_gate; // dimensionless
            NekDouble alpha_n = Q10T * gate_n_alphaA * ComputeexpM1( gate_n_alphaB - var_membrane_V, gate_n_alphaC);
            NekDouble beta_n = Q10T * gate_n_betaA * ComputeexpM1( var_membrane_V - gate_n_betaB, gate_n_betaC);
            NekDouble n_inf = alpha_n/(alpha_n + beta_n);
            NekDouble n_tau = 1.0/(alpha_n + beta_n);

            // h gate: h_inf = (alpha_h / (alpha_h + beta_h) ),   h_tau = (1.0 / (alpha_h + beta_h) )
            // const NekDouble var_current_h = var_h_gate; // dimensionless
            NekDouble alpha_h = Q10T * gate_h_alphaA * ComputeexpM1( var_membrane_V - gate_h_alphaB, gate_h_alphaC);
            NekDouble beta_h = Q10T * gate_h_betaA / ( exp((gate_h_betaB - var_membrane_V)/gate_h_betaC ) + 1.0 );
            NekDouble h_inf = alpha_h/(alpha_h + beta_h);
            NekDouble h_tau = 1.0/(alpha_h + beta_h);

            // p gate: p_inf = (alpha_p / (alpha_p + beta_p) ),   p_tau = (1.0 / (alpha_p + beta_p) )
            // const NekDouble var_current_p = var_p_gate; // dimensionless
            NekDouble alpha_p = Q10T * gate_p_alphaA * ComputeexpM1( gate_p_alphaB - var_membrane_V, gate_p_alphaC);
            NekDouble beta_p = Q10T * gate_p_betaA * ComputeexpM1( var_membrane_V - gate_p_betaB, gate_p_betaC);
            NekDouble p_inf = alpha_p/(alpha_p + beta_p);
            NekDouble p_tau = 1.0/(alpha_p + beta_p);

            // Compute current_K
            E = var_membrane_V + var_membrane__Vrest;
            NekDouble ZK = ComputeIon(E, var_membrane__K_i, var_membrane__K_o,var_membrane__Tc);
            NekDouble ZNa = ComputeIon(E, var_membrane__Na_i, var_membrane__Na_o,var_membrane__Tc);

            NekDouble var_J_K = var_membrane__PK * var_current_n * var_current_n * ZK;
            NekDouble var_J_Na = var_membrane__PNa * var_current_m * var_current_m * var_current_h * ZNa;
            NekDouble var_J_p = var_membrane__Pp * var_current_p * var_current_p * ZNa;
            NekDouble var_J_l = var_membrane__gL * ( var_membrane_V - var_membrane__VL);

            // Ranvider node: -J_{ion}
            if(zoneindex[i]>=0)
            {
                outarray[0][i] = -1.0 * m_pi * var_membrane__d * ( var_J_K + var_J_Na + var_J_p + var_J_l ) / var_membrane__cnd;
            }

            // Myelin node: - g_m V_k
            else if(zoneindex[i]==-1)
            {
                outarray[0][i] = -1.0 * var_membrane__gm * var_membrane_V / var_membrane__cml ;
            }

            else 
            {
                outarray[0][i] = 0.0;
            }

            // gate variable 1: m 
            // gate variable 2: n
            // gate variable 3: h
            // gate variable 4: p
            outarray[1][i] = m_inf;
            m_gates_tau[0][i] = m_tau;

            outarray[2][i] = n_inf;
            m_gates_tau[1][i] = n_tau; 

            outarray[3][i] = h_inf;
            m_gates_tau[2][i] = h_tau;

            outarray[4][i] = p_inf;
            m_gates_tau[3][i] = p_tau;
        }
    }

    // void FrankenHuxley::v_Update(
    //                  const Array<OneD, const int> &NodeZone,
    //                  const Array<OneD, const  Array<OneD, NekDouble> >&inarray,
    //                        Array<OneD,        Array<OneD, NekDouble> >&outarray,
    //                                                        const NekDouble time,
    //                                                        const NekDouble var_membrane__Tc)
    // {
    //     boost::ignore_unused(time);

    //     const NekDouble var_membrane__cnd = 3.14e-9; 
    //     const NekDouble var_membrane__cml = 1.87e-11; 

    //     // const NekDouble var_membrane__R = 8.3145; // gas constant: (J / mol / K)
    //     // const NekDouble var_membrane__F = 96485.3; // Faraday constant: (C / mol)

    //     const NekDouble var_membrane__PNa = 0.008; //Max. Na, f channel permeability (cm/s)
    //     const NekDouble var_membrane__Pp = 0.00054; //Max. Na, p channel permeability (cm/s)
    //     const NekDouble var_membrane__PK = 0.0012; //Max. K channel permeability (cm/s)

    //     // const NekDouble var_membrane__Na_o = 114.5; // External Na^{+} concentration (mM)
    //     // const NekDouble var_membrane__Na_i = 13.74; // internal Na^{+} concentration (mM)
    //     // const NekDouble var_membrane__K_o = 2.5; // External K^{+} concentration (mM)
    //     // const NekDouble var_membrane__K_i = 120.0; // internal K^{+} concentration (mM)

    //     const NekDouble var_membrane__Na_o = 0.1145; // External Na^{+} concentration (mol)
    //     const NekDouble var_membrane__Na_i = 0.01374; // internal Na^{+} concentration (mol)
    //     const NekDouble var_membrane__K_o = 0.0025; // External K^{+} concentration (mol)
    //     const NekDouble var_membrane__K_i = 0.1200; // internal K^{+} concentration (mol)

    //     const NekDouble var_membrane__gL = 0.0303; //Leakage-specific conductance (mho/cm2)

    //     // const NekDouble var_membrane__d = 1.0e-3; // bare Axon diameter(cm)
    //     // const NekDouble var_membrane__D = 1.5e-3; // myelinated Axon diameter(cm)
    //     // const NekDouble var_membrane__l = 2.5e-4; // Nodal length (cm)
    //     // const NekDouble var_membrane__L = 2.0e-1; // Internoal length (cm)

    //     const NekDouble var_membrane__gm = 5.60e-9; // Myelin conductance (F/cm)
    //     const NekDouble var_membrane__VL = 0.026; //Leakage potential (mV)

    //     // m-gate constant 
    //     const NekDouble gate_m_alphaA = 0.36 ; // ms^{-1}
    //     const NekDouble gate_m_alphaB = 22.0 ; // mV
    //     const NekDouble gate_m_alphaC = 3.0 ; // mV
    //     const NekDouble gate_m_betaA = 0.4; // ms^{-1}
    //     const NekDouble gate_m_betaB = 13.0 ; // mV
    //     const NekDouble gate_m_betaC = 20.0 ; // mV

    //     // n-gate constant 
    //     const NekDouble gate_n_alphaA = 0.02 ; // ms^{-1}
    //     const NekDouble gate_n_alphaB = 35.0 ; // mV
    //     const NekDouble gate_n_alphaC = 10.0 ; // mV
    //     const NekDouble gate_n_betaA = 0.05 ; // ms^{-1}
    //     const NekDouble gate_n_betaB = 10.0 ; // mV
    //     const NekDouble gate_n_betaC = 10.0 ; // mV

    //     // h-gate constant 
    //     const NekDouble gate_h_alphaA = 0.1 ; // ms^{-1}
    //     const NekDouble gate_h_alphaB = -10.0 ; // mV
    //     const NekDouble gate_h_alphaC = 6.0 ; // mV
    //     const NekDouble gate_h_betaA = 4.5  ; // s^{-1}
    //     const NekDouble gate_h_betaB = 45.0 ; // mV
    //     const NekDouble gate_h_betaC = 10.0 ; // mV

    //     // p-gate constant 
    //     const NekDouble gate_p_alphaA = 0.006 ; // ms^{-1}
    //     const NekDouble gate_p_alphaB = 40.0 ; // mV
    //     const NekDouble gate_p_alphaC = 10.0 ; // mV
    //     const NekDouble gate_p_betaA = 0.09 ; // ms^{-1}
    //     const NekDouble gate_p_betaB = -25.0 ; // mV
    //     const NekDouble gate_p_betaC = 20.0 ; // mV

    //     NekDouble var_membrane_V, var_current_m, var_current_n, var_current_h, var_current_p;

    //     NekDouble d_dt_membrane__V =0.0;

    //     NekDouble Q10Tpow = 0.1*(var_membrane__Tc-20.0);
    //     NekDouble Q10T = pow(3.0, Q10Tpow);
    //     for (unsigned int i = 0; i < m_nq; ++i)
    //     {
    //         // Time units: millisecond
    //          var_membrane_V = inarray[0][i];
    //         // Units: millivolt; Initial value: -84.3801107371
    //          var_current_m = inarray[1][i];
    //         // Units: dimensionless; Initial value: 0.00171338077730188
    //          var_current_n = inarray[2][i];
    //         // Units: dimensionless; Initial value: 0.982660523699656
    //          var_current_h = inarray[3][i];
    //         // Units: dimensionless; Initial value: 0.989108212766685
    //          var_current_p = inarray[4][i];
    //         // Units: millimolar; Initial value: 0.00017948816388306

    //         // m gate: m_inf = (alpha_m / (alpha_m+beta_m) ),   m_tau = (1.0 / (alpha_m+beta_m) )/ Q10(T)
    //         // const NekDouble var_current_m = var_m_gate; // dimensionless
    //         NekDouble alpha_m = Q10T * gate_m_alphaA * ComputeexpM1( gate_m_alphaB - var_membrane_V, gate_m_alphaC);
    //         NekDouble beta_m = Q10T * gate_m_betaA * ComputeexpM1( var_membrane_V - gate_m_betaB, gate_m_betaC);
    //         NekDouble m_inf = alpha_m/(alpha_m + beta_m);
    //         NekDouble m_tau = 1.0/(alpha_m + beta_m);

    //         // n gate: n_inf = (alpha_n / (alpha_n + beta_n) ),   n_tau = (1.0 / (alpha_n + beta_n) )
    //         // const NekDouble var_current_n = var_n_gate; // dimensionless
    //         NekDouble alpha_n = Q10T * gate_n_alphaA * ComputeexpM1( gate_n_alphaB - var_membrane_V, gate_n_alphaC);
    //         NekDouble beta_n = Q10T * gate_n_betaA * ComputeexpM1( var_membrane_V - gate_n_betaB, gate_n_betaC);
    //         NekDouble n_inf = alpha_n/(alpha_n + beta_n);
    //         NekDouble n_tau = 1.0/(alpha_n + beta_n);

    //         // h gate: h_inf = (alpha_h / (alpha_h + beta_h) ),   h_tau = (1.0 / (alpha_h + beta_h) )
    //         // const NekDouble var_current_h = var_h_gate; // dimensionless
    //         NekDouble alpha_h = Q10T * gate_h_alphaA * ComputeexpM1( var_membrane_V - gate_h_alphaB, gate_h_alphaC);
    //         NekDouble beta_h = Q10T * gate_h_betaA / ( exp((gate_h_betaB - var_membrane_V)/gate_h_betaC ) + 1.0 );
    //         NekDouble h_inf = alpha_h/(alpha_h + beta_h);
    //         NekDouble h_tau = 1.0/(alpha_h + beta_h);

    //         // p gate: p_inf = (alpha_p / (alpha_p + beta_p) ),   p_tau = (1.0 / (alpha_p + beta_p) )
    //         // const NekDouble var_current_p = var_p_gate; // dimensionless
    //         NekDouble alpha_p = Q10T * gate_p_alphaA * ComputeexpM1( gate_p_alphaB - var_membrane_V, gate_p_alphaC);
    //         NekDouble beta_p = Q10T * gate_p_betaA * ComputeexpM1( var_membrane_V - gate_p_betaB, gate_p_betaC);
    //         NekDouble p_inf = alpha_p/(alpha_p + beta_p);
    //         NekDouble p_tau = 1.0/(alpha_p + beta_p);

    //         // Compute current_K
    //         NekDouble ZK = Computeghz(var_membrane_V, var_membrane__K_i, var_membrane__K_o,var_membrane__Tc);
    //         NekDouble ZNa = Computeghz(var_membrane_V, var_membrane__Na_i, var_membrane__Na_o,var_membrane__Tc);

    //         NekDouble var_J_K = var_membrane__PK * var_current_n * var_current_n * ZK;
    //         NekDouble var_J_Na = var_membrane__PNa * var_current_m * var_current_m * var_current_h * ZNa;
    //         NekDouble var_J_p = var_membrane__Pp * var_current_p * var_current_p * ZNa;
    //         NekDouble var_J_l = var_membrane__gL * ( var_membrane_V - var_membrane__VL);

    //         // Myelin node: - g_m V_k
    //         if(NodeZone[i]==-1)
    //         {
    //             d_dt_membrane__V = var_membrane__gm * var_membrane_V / var_membrane__cml ;
    //         }

    //         // Ranvider node: -J_{ion}
    //         else if(NodeZone[i]>=0)
    //         {
    //             d_dt_membrane__V = ( var_J_K + var_J_Na + var_J_p + var_J_l ) / var_membrane__cnd;
    //         }

    //         else
    //         {
    //             d_dt_membrane__V = 0.0;
    //         }

    //         outarray[0][i] = -1.0 * d_dt_membrane__V;

    //         // gate variable 1: m 
    //         // gate variable 2: n
    //         // gate variable 3: h
    //         // gate variable 4: p
    //         outarray[1][i] = m_inf;
    //         m_gates_tau[0][i] = m_tau;

    //         outarray[2][i] = n_inf;
    //         m_gates_tau[1][i] = n_tau; 

    //         outarray[3][i] = h_inf;
    //         m_gates_tau[2][i] = h_tau;

    //         outarray[4][i] = p_inf;
    //         m_gates_tau[3][i] = p_tau;

    //         std::cout << "i = " << i << ", NodeZone = " << NodeZone[i] << ", du/dt = " << outarray[0][i] << ", m = " << outarray[1][i]
    //         << ", n = " << outarray[2][i]  << ", h = " << outarray[3][i] << ", p = " << outarray[3][i] << std::endl;
    //         std::cout << "var_J_K = " << var_J_K  << ", var_J_Na = " << var_J_Na << ", var_J_p = " << var_J_p << ", var_J_l = " << var_J_l << std::endl << std::endl;
    //     }
    // }

    void FrankenHuxley::v_GenerateSummary(SummaryList& s)
    {
        SolverUtils::AddSummaryItem(s, "Neuron model", "Frankenhaeuser Huxley 64");
    }

    void FrankenHuxley::v_SetInitialConditions()
    {
        Vmath::Fill(m_nq, 0.0,       m_NeuronSol[0],  1);
        Vmath::Fill(m_nq, 0.0005,    m_NeuronSol[1],  1);
        Vmath::Fill(m_nq, 0.0268,    m_NeuronSol[2],  1);
        Vmath::Fill(m_nq, 0.8249,    m_NeuronSol[3],  1);
        Vmath::Fill(m_nq, 0.0049,    m_NeuronSol[4],  1);
    }

    // Compute x/ (exp x/y -1.0)
    NekDouble FrankenHuxley::ComputeexpM1(const NekDouble x, const NekDouble y)
    {
        NekDouble expM1;
        if (fabs(x/y) < 1e-6)
        {
            expM1 = y*(1.0 - x/y/2.0);
        }

        else
        {
            expM1 = x/(exp(x/y) - 1.0);
        }

        return expM1;
    }

    // v (mV), ci (mV), co (mV), Tc (C)
    NekDouble FrankenHuxley::ComputeIon(const NekDouble E, const NekDouble ci, const NekDouble co, const NekDouble Tc)
    {
        const NekDouble var_membrane__R = 8.3145; // gas constant: (J / mol / K)
        const NekDouble var_membrane__F = 96484.6; // Faraday constant: (C / mol)

        NekDouble var_membrane__T = Tc + 273.15; // kelvin
        NekDouble z, outval;

        z = 0.001 * var_membrane__F * E / ( var_membrane__R *  var_membrane__T ) ;

        // ci * efun(-1.0*z) - co * (z/(exp(z)-1)) = - [ ( co - ci * exp(z)) / (exp(z) - 1) ]
        outval = 0.001 * var_membrane__F * ( ci * efun(-1.0*z) - co * efun(z) );

        return outval;
    }

    NekDouble FrankenHuxley::efun(const NekDouble z)
    {
        NekDouble efun;

        if (fabs(z) < 1.0e-4)
        {
            efun = 1 - 0.5*z;
        }

        else
        {
            efun = z/(exp(z) - 1.0);
        }

        return efun;
    }
}
        
